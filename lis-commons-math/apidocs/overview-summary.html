<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="de">
<head>
<!-- Generated by javadoc (1.8.0_201) on Wed Sep 14 08:53:23 CEST 2022 -->
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Overview (LIS Commons Math 1.8.2-SNAPSHOT API)</title>
<meta name="date" content="2022-09-14">
<link rel="stylesheet" type="text/css" href="stylesheet.css" title="Style">
<script type="text/javascript" src="script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="Overview (LIS Commons Math 1.8.2-SNAPSHOT API)";
        }
    }
    catch(err) {
    }
//-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li class="navBarCell1Rev">Overview</li>
<li><a href="com/link_intersystems/math/package-summary.html">Package</a></li>
<li>Class</li>
<li>Use</li>
<li><a href="overview-tree.html">Tree</a></li>
<li><a href="deprecated-list.html">Deprecated</a></li>
<li><a href="index-all.html">Index</a></li>
<li><a href="help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li>Prev</li>
<li>Next</li>
</ul>
<ul class="navList">
<li><a href="index.html?overview-summary.html" target="_top">Frames</a></li>
<li><a href="overview-summary.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<a name="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<div class="header">
<h1 class="title">LIS Commons Math 1.8.2-SNAPSHOT API</h1>
</div>
<div class="header">
<div class="subTitle">
<div class="block">The following conventions apply to this package and all of it's
        sub-packages.</div>
</div>
<p>See: <a href="#overview.description">Description</a></p>
</div>
<div class="contentContainer">
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Packages table, listing packages, and an explanation">
<caption><span>Packages</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Package</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tbody>
<tr class="altColor">
<td class="colFirst"><a href="com/link_intersystems/math/package-summary.html">com.link_intersystems.math</a></td>
<td class="colLast">
<div class="block">Provides mathematical components and algorithm add-ons to the java.lang.math
 package.</div>
</td>
</tr>
</tbody>
</table>
</div>
<div class="contentContainer"><a name="overview.description">
<!--   -->
</a>
<div class="block">The following conventions apply to this package and all of it's
        sub-packages.

        <h1>Architecture</h1>
        <h2>Version Numbering</h2>
        <p>An API is the important contract between a client and a service.
                Therefore API changes must be tracked using version numbers. The
                version numbering must reflect the changes of the service and provide
                information about breaking API changes that might affect a client. The
                version numbering must ensure that every breaking API change is
                tracked.
        <p>We track API changes via a 4 digit version pattern with a
                qualifier segment.</p>
        <pre>
+- facade segment
| +- major segment
| | +- minor segment
| | | +- service segment
| | | |  +- qualifier segment
| | | |  |
V V V V  V
1.2.3.4-SNAPSHOT
</pre>
        <ul>
                <li><b>facade segment</b><br /> See the <a href="#facades">definition</a>
                        of components that belong to a facade segment for details. If clients
                        only use facades they will only be affected if the first version
                        number (facade segement) changes. Change from version 1.2.4; to
                        1.3.2.1 will not affect a client that only uses facades.</li>
                <li><b>major segment</b><br /> This version number segment is
                        increased whenever a breaking api change occurs in one of the
                        package's classes or interfaces that are <a href="#public_api">public
                                api</a>. See <a href="http://wiki.eclipse.org/Evolving_Java-based_APIs">Evolving
                                Java-based APIs</a> for details on what constitutes a breaking change.</li>
                <li><b>minor segment</b><br /> This segment is defined equal to
                        the definition of a minor segment in <a
                        href="http://wiki.eclipse.org/index.php/Version_Numbering">Version
                                Numbering</a></li>
                <li><b>service segment</b><br /> This segment is defined equal
                        to the definition of a service segment in <a
                        href="http://wiki.eclipse.org/index.php/Version_Numbering">Version
                                Numbering</a>. In short: bug fixes that do not affect client code.</li>
                <li><b>qualifier segment</b><br /> The qualifier segment marks a
                        version as a development version. That means that it is work in
                        progress and the API might change unexpectedly. Therefore you should
                        not implement against SNAPSHOT versions. The version number before
                        the SNAPSHOT segment is the number that will be released when the
                        development of that SNAPSHOT version is finished. Only use libraries
                        with such a version if you want to integrate against the next
                        release. These versions must not be used in production, because they
                        can lead to unpredictable behavior, rebuild of your software might
                        not work and therefore bugs might not be reproducible.</li>
        </ul>

        <h2 id="public_api">The public api</h2>
        We use the same definition of a public API as defined by
        <a
                href="http://wiki.eclipse.org/index.php/Evolving_Java-based_APIs#API_Java_Elements">&quot;API
                Java Elements&quot;</a>, Jim des Rivi√®res, IBM.
        <blockquote>
                <ul>
                        <li>API package - a package that contains at least one API class
                                or API interface. The names of API packages are advertised in the
                                Component documentation. These names will appear in Client code; the
                                names of non-API packages should never appear in Client code. Note
                                that Clients must be prohibited from declaring their code in
                                Component packages (API or otherwise).</li>
                        <li>API class - a public class in an API package, or a public or
                                protected class member declared in, or inherited by, some other API
                                class or interface. The names of API classes appear in Client code.</li>
                        <li>API interface - a public interface in an API package, or a
                                public or protected interface member declared in, or inherited by,
                                some other API class or interface. The names of API interfaces
                                appear in Client code.</li>
                        <li>API method - a public or protected method either declared
                                in, or inherited by, an API class or interface. The names of API
                                methods appear in Client code.</li>
                        <li>API constructor - a public or protected constructor of an
                                API class. The names of API constructors appear in Client code.</li>
                </ul>
                <p>
                        The following elements are <strong>not considered API</strong>:
                </p>
                <ul>
                        <li>Any package that is not advertised in the Component
                                documentation as an API package.</li>
                        <li>All classes and interfaces declared in non-API packages.
                                However, when API classes and interface extend or implement non-API
                                classes, the non-API classes and interface may contribute API
                                elements nevertheless.</li>
                        <li>Non-public classes and interfaces in API packages.</li>
                        <li>Default access and private methods, constructors, fields,
                                and type members declared in, or inherited by, API classes and
                                interfaces.</li>
                        <li>protected methods, constructors, fields, and type members
                                declared in, or inherited by, final API classes, including enums
                                (which are implicitly final). With no ability to declare subclasses,
                                these cannot be referenced by Client code.</li>
                </ul>
        </blockquote>

        <h2>Packages</h2>
        <h3>Structure and naming</h3>
        <p>

                A package defines the boundary of classes and interfaces that belong
                together to fulfill some special purpose. In contrast to classes and
                interfaces a package is a coarse-grained perspective. A package can be
                named and therefore give a set of classes and interfaces a meaning.
                The name should always be chosen in order to increase the clarity of
                understanding of a system and should not give any technical or
                implementation hints. It's bad practice to separate interfaces from
                their implementation by putting them in sub-packages named
                <code>impl</code>
                . For details see
                <code>://www.link-intersystems.com
                        /bin/view/Blog/Wise+separation+of+api+and+implementation</code>
                . <br> Packages might contain sub-packages. A sub-package should
                be seen as a
                <code>"is part of"</code>
                relationship. E.g if you have a package called
                <code>building</code>
                the
                <code>floor</code>
                package should be a sub package with the full qualified name
                <code>building.floor</code>
                .
        </p>
        <p>
                Packages are named after the singular form of a substantive that
                describes the package. So a packages should be named
                <code>floor</code>
                instead of
                <code>floors</code>
                .
        </p>
        <h3 id="facades">Facades</h3>
        <p>
                A package might be a complex system that is hard to understand, to
                configure and to manage. Therefore a package can provide a high level
                abstraction of the common use cases that hides the complexity of
                interactions of it's classes from clients. E.g. a http protocol
                package might contain a get object a http connection manager, a proxy
                configuration, a content object and or transformer and so on. While
                these fine-grained components are useful for a good design,
                maintainability and professional users they are too complex for easy
                use cases like most clients are interested in. E.g.
                <code>String content = new
                        URL("http://www.somesite.com").getContent();</code>
                . For those use cases the package should provide a facade that
                encapsulates the common use cases in an easy way. This facade should
                be named after the package and postfixed with
                <code>Facade</code>
                . E.g.
                <code>ReflectionFacade</code>
                . The facade must be an interface and it's implementation is available
                through the service provider specification as defined in the jar file
                specification (META-INF/services). For this purposes clients can use
                an instance of the
                <code>com.link_intersystems.lang.services.JarFileSpecificationServiceLocator</code>
                that implements the
                <code>com.link_intersystems.lang.services.ClassServiceLocator</code>
                interface. All facades must be stateless which means that the state of
                the facade must not be tied to a client's call history. Nevertheless a
                facade can act as a factory for objects that are stateful.
        </p>

        <h2>General API contracts</h2>
        <p>An API is the significant contract between a client and a
                service. Therefore API changes must be tracked using version numbers.
                The version numbering must reflect the changes of the service and
                provide information about breaking API changes that might affect a
                client. The version numbering must ensure that every breaking API
                change is tracked. To learn more about API and breaking API changes
                take a look at http://wiki.eclipse.org/Evolving_Java-based_APIs.</p>
        <h3>Invocation arguments contract</h3>
        Every defined parameter of an invokable object (method or constructor)
        must not be
        <code>null</code>
        .
        <br> If a method allows a parameter to be
        <code>null</code>
        it must be explicitly documented in the parameter's javadoc. Every
        method or constructor should only define parameters that it needs.
        Parameters that can be
        <code>null</code>
        confuse the client and make the implementation code harder to
        understand, because it must handle a lot more possible pre-conditions.
        If a parameter is optional the method or constructor should be
        overloaded to provide a clear API for the client and separate the
        different pre-condition constraint validations.
        <br> Here is an example of a clear API.

        <pre> public void doSomething(Range range){
        if(range == null){
                throw new IllegalArgumentException("range must not be null");
        }
  ...
 }
 </pre>

        The Range parameter object does enforces your API constraints.

        <pre> public class Range {

        private final int start;
        private final int end;

        public Range(int start, int end) {
                if (start &gt; end) {
                        throw new IllegalArgumentException(
                                        "start must be less than end, but was " + start + " &gt;  "
                                                        + end);
                }
                this.end = end;
                this.start = start;
        }

        public boolean within(int value) {
                return start &lt;= value &amp;&amp; value &lt;= end;
        }

        public int getStart() {
                return start;
        }

        public int getEnd() {
                return end;
        }
 }
 </pre>
        <h3>Return values</h3>
        Every method that declares a return type must return an object of that
        type and never
        <code>null</code>
        . Methods that return a
        <a
                href="http://download.oracle.com/javase/1.5.0/docs/api/java/util/Collection.html?is-external=true"
                title="class or interface in java.util"><code>Collection</code></a>
        type must return an empty
        <a
                href="http://download.oracle.com/javase/1.5.0/docs/api/java/util/Collection.html?is-external=true"
                title="class or interface in java.util"><code>Collection</code></a>
        instead of
        <code>null</code>
        . If a method does not comply to this contract it must be documented in
        the method's javadoc. In some cases the returned object might be used
        by the client and in other situations it might not be used. If it is an
        expensive operation to construct the return object and the method can
        not know if it will ever by used, consider to return a
        <code>lazy proxy</code>
        or
        <a href="../../com/link_intersystems/lang/ref/Reference.html"
                title="interface in com.link_intersystems.lang.ref"><code>Reference</code></a>
        instead.</div>
</div>
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li class="navBarCell1Rev">Overview</li>
<li><a href="com/link_intersystems/math/package-summary.html">Package</a></li>
<li>Class</li>
<li>Use</li>
<li><a href="overview-tree.html">Tree</a></li>
<li><a href="deprecated-list.html">Deprecated</a></li>
<li><a href="index-all.html">Index</a></li>
<li><a href="help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li>Prev</li>
<li>Next</li>
</ul>
<ul class="navList">
<li><a href="index.html?overview-summary.html" target="_top">Frames</a></li>
<li><a href="overview-summary.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<a name="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
<p class="legalCopy"><small>Copyright &#169; 2011&#x2013;2022 <a href="http://www.link-intersystems.com">Link Intersystems GmbH</a>. All rights reserved.</small></p>
</body>
</html>